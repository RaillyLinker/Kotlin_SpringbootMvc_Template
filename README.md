# Kotlin Springboot MVC Template Project

## 프로젝트 설명

- 본 프로젝트는 멀티 모듈 구조의 Springboot 개발 템플릿 프로젝트입니다.<br>
  멀티 모듈의 구조는 Layered 아키텍쳐를 커스텀한 것이며,<br>
  모듈 내 폴더 구조 역시 일반성과 가독성을 고려하여 클래스 파일 용도별 분류를 하였습니다.

## 프로젝트 설명 상세

### 모듈 분리 기준

본 프로젝트에서 모듈은 기본적으로 Layered 아키텍쳐 방식으로 구성하였습니다.<br>

각 모듈별 종속성의 흐름은 하나의 방향성을 가지며, 동일 계층간의 참조는 있을 수 있지만,<br>
하위 계층에서의 참조 방향의 역전은 있을 수 없습니다.<br>

예를 들어, <br>

A 모듈이 B, C 모듈을 참조하고 있고, B 모듈이 D, E 모듈을 참조한다면,<br>
A 모듈은 B, C 모듈과 D, E 모듈을 모두 참조가 가능하고,<br>
(되도록 D, E 모듈은 A 모듈에선 사용하지 않는 것을 권장하고, 모듈 연관관계 도식은 필수)<br>
B, C 모듈은 동일 계층인 B, C 와 D, E 모듈을 모두 참조 가능하지만, A 모듈은 참조할 수 없습니다.<br>

또한, 모듈의 분리 기준은,<br>
크게는 기능 단위로 나누어주고, 작게는 api 서비스 단위로 나누어 줍니다.<br>

예를 들어,<br>
app 모듈은 프로젝트 시작을 담당하는 main 함수 및 서버 프로세스의 포트와 같은 설정 담당,<br>
api 모듈은 Springboot MVC 에서의 Controller, Service 담당,<br>
jpa 모듈은 jpa Database 기능 담당.<br>
위와 같이 기능단위로 나누며,<br>

api 모듈과 같이 사용자에게서 온 요청을 받아와서 처리하는 모듈은 서비스 단위를 기준으로 하여,
회원 가입, 로그인과 같은 요청을 처리하는 auth 서비스 단위, 게시판 기능을 담당하는 board 서비스 단위...<br>
이런식으로 하위 서비스 도메인 단위로 모듈을 분리합니다.<br>

즉, 모듈의 종속성을 한방향으로 하여 구조의 복잡도를 낮추고,<br>
모듈을 기능 및 서비스 도메인 단위로 나누어 관심사의 분리를 이루어내어 코드의 복잡성을 낮췄습니다.

실무적인 모듈 분리의 순서를 설명드리자면,<br>

1. 어떠한 기능을 필요에 따라 api 모듈 Service 에서 개발
2. 해당 기능의 코드가 api 기능과는 별개의 영역을 다룬다면, 별도 모듈로 이관 가능한지 확인
3. 별도 모듈로 떼어내는 것이 맞고, 뚜렷한 토픽이 없다면 이 코드를 common 모듈의 함수로 분리
4. 별도 모듈로 분리가 가능하고, 뚜렷한 토픽이 있다면 해당 토픽의 모듈에 이식하고, 만약 기존 모듈이 없다면 새로운 모듈 생성

위와 같습니다.<br>

모듈 분리의 권장 규칙은,<br>

1. 동일 계층 모듈을 참조할 수도 있지만 되도록 하위 모듈만 사용하도록 하기
2. 할 수 있다면 다른 모듈을 참조하지 않는 독립 모듈을 지향하기
3. 각 모듈별 토픽을 엄격히 지키기 (ex : api 모듈은 controller 와 service 만 작성)

위와 같은 구조로 인하여 얻을 수 있는 장점은,<br>
모듈화의 장점인 이식성의 향상과 결합성의 약화를 이루어내고,<br>
구조의 일관된 규칙을 통해 프로젝트 파악의 난이도를 낮추고,<br>
모듈별 단위 테스트를 따로 두어 모듈별 신뢰도를 높이고 분리하여,<br>
오래된 코드에 들어가는 에너지 소모를 막을 수 있으며,<br>
단순한 모듈 구조로 인해 비숙련자도 쉽게 적응이 가능하도록 설계하였습니다.

## 프로젝트 실행 방법

본 프로젝트를 실행시키기 위해서 필요한 조건이 존재합니다.<br>
MySQL or MariaDB, Redis, MongoDB, Kafka<br>
위의 네가지 서비스가 로컬상에 동작해야하며,<br>
RDBMS 는 JPA 모듈에서 설정한 Entity 의 스키마, 테이블 구조를 따라야 합니다.<br>

특히, DB 테이블 구조가 갖춰지지 않는다면 실행 오류가 날 것이며,<br>
JPA 모듈에서는 entities 안의 엔티티 테이블 클래스를 참조하여 DB 구조를 맞춰주시고,<br>
batch 모듈에서는 SpringBatch 에 필요한 Batch 관련 테이블로써,<br>

Gradle 빌드 후 생성되는 외부 라이브러리의<br>
Gradle: org.springframework.batch:spring-batch-core<br>
안의 jar 파일에서 org.springframework.batch.core 안의 sql 파일 내의 내용에 따라<br>
batch_metadata 스키마 안에 테이블을 생성하고,<br>

quartz 모듈은 external_files 안의 knowledges 하위 폴더의 SpringQuartzMySQL.txt 의 SQL 문으로<br>
quartz_metadata 스키마 안에 테이블을 생성하면 됩니다.

모듈별 미들웨어 서비스는 external_files 안의 docker 모음으로 설치가 가능하며,<br>

각 서비스들에 대한 설정은 각 구현 모듈 설정을 변경시켜 실행시킬 수 있습니다.<br>

프로젝트를 정상적으로 실행시켜 Open 된 포트에 웹 브라우저로 접속한다면, 서버의 Welcome 페이지를 확인하실 수 있고,<br>

서버에서 제공해주는 Swagger 문서를 통하여 본 프로젝트에서 구현된 여러 기능들을 테스트 하실 수 있습니다.<br>
(배포 설정인 prod80 프로필로 접속시 보안을 위하여 Swagger 페이지 접속 버튼이 사라지며, Swagger 주소 접근 역시 불가능해 집니다.)

## MSA 구축 철학
기본적으로 본 프로젝트는 서비스 하나를 가정합니다.<br>
이곳에 모든 기능을 다 넣으면 모놀리틱 아키텍쳐가 되는 것이고,<br>
일부 기능을 구현한다면 마이크로 서비스 아키텍쳐의 일부가 되는 것이죠.<br>

저는 서비스 구현을 프로젝트 당 하나의 기능을 담당하도록 만드는 것을 선호합니다.<br>

간혹 프로젝트 내에 멀티 모듈을 구현하여 모듈별 실행 Main 함수를 따로두고, 포트 설정을 바꾸는 형식으로 구현하기도 하는데,<br>
해당 방식이 나쁘다기보다는 MSA 는 기술이 아닌 설계의 영역에 가깝다고 생각하므로, 기술과 독립이 되어야 하며,<br>
추후 관리시 서비스가 프로젝트 단위로 분리되어 있는 것이 보다 서비스간 독립성을 보장한다고 생각하기 때문입니다.<br>

예를들어 같은 MSA 를 구성하는 서로 다른 언어로 구현된 마이크로 서비스들 간에는 프로젝트 단위로 분리를 하므로,<br>
어떤 것은 동일 프로젝트를 공유하고, 어떤 것은 다른 프로젝트로 분리되는 식으로 예외를 주기 보다는<br>
모든 서비스가 프로젝트 단위로 분리되는 것이 이해가 쉽고, 특정 기술에 종속성을 가지지 않는 설계라고 생각합니다.<br>

즉, 제가 MSA 를 구성한다면,<br>
본 프로젝트 구조를 그대로 가져가며, 설계 단계에서 DDD 에 따라 서비스 도메인과 하부 도메인을 설계한 후,<br>
마이크로 서비스 설계에 맞게 프로젝트를 분리하여 각 서비스를 구현하는 방식을 사용할 것이며,<br>
더 나아가서 Spring Cloud(API 기반이므로 NodeJS, Python 서버 등 호환 가능) 스택과 같은 마이크로 서비스 툴을 사용하여,<br>
MSA 운영시의 안정성을 재고할 것입니다.

## 모듈 단위 설명

본 프로젝트에서 구현한 모듈은 크게 4가지로 나눌 수 있습니다.<br>
실행 main 이 포함되고, 포트 번호를 결정짓는 app 모듈,<br>
app 모듈에게 바로 사용되며, api 컨트롤러 역할을 하거나, 배치 작업을 실행하거나, 스케쥴 작업을 실행하거나, 소켓, kafka 와 같이 시스템 컴포넌트에 등록된 상황에서 스스로 독립적으로 활동하는 실행성 모듈,<br>
다른 어떤 모듈도 참조하지 않고 스스로 동작하는 JPA, Redis, Mongodb 등과 같은 독립성 모듈,<br>
사용성 모듈과 독립성 모듈 사이에 위치하여 둘을 잇는 역할을 하는 중위 모듈...<br>
이렇게 나누었습니다.

### 루트

싱글 모듈 구조에 해당하는 루트 경로의 src 코드는 제거하여 존재하지 않는 상태입니다.<br>
루트 경로에 남아있는 파일/폴더를 설명드리자면,<br>

- by_product_files<br>
  프로젝트 부산물 파일들을 저장하는 경로.<br>
  로그 파일 등이 위치하며, gitignore 에 등록됩니다.
- .gitignore<br>
  git 에서 무시할 목록을 적는 파일
- build.gradle<br>
  하위 모듈들에서 사용하는 Gradle Plugins 와 버전들을 설정하고,<br>
  프로젝트에서 사용하는 프로그래밍 언어 버전 설정,<br>
  하위 모듈들에서 사용하는 공통의 종속성 라이브러리 설정을 담당합니다.<br>

### app 모듈

app 모듈은 서버 프로젝트의 main 함수가 위치한 시작점이라 할 수 있습니다.<br>
서버 프로세스 실행시 사용할 포트 번호,<br>
하위 모든 모듈들에 적용되는 설정,<br>
api, kafka, socket, scheduler 와 같이 서버 실행시 실행되는 하위 모듈 조립<br>
하위 모듈들의 application.yml 을 조합하는 역할을 담당합니다.<br>

### api 모듈

api 모듈은 실행성 모듈로, 클라이언트의 요청을 받고 응답을 보내주는 Controller 의 역할을 합니다.<br>
controllers 에는 입출력 api 를 명시하는 역할을 하는 컨트롤러 클래스를 작성하며,<br>
services 에는 controller 의 비즈니스 로직을 구현하는 Service 클래스를 작성합니다.<br>
api 모듈은 일반적으로 한 프로젝트 내에 여러개로 이루어질 수 있으며,<br>
본인의 설계 규칙에 따라 도메인 단위로 api 모듈을 분리하는데, 모듈의 명명법은 해당 모듈 내의 컨트롤러가 담당하는 URL 에 따릅니다.<br>
예를들어 로그인, 회원가입, 회원 정보 수정 등의 계정 정보 기능을 담당하는 모듈을 만들때,<br>
/my-service/tk/auth 라는 주소를 사용한다고 하면, 모듈을 module-api-my_service-tk-auth 라고 합니다.<br>
보이듯, module-api 는 api 모듈의 기본 이름이고, 뒤에는 주소상 - 로 이어져있다면 _ 를 사용하고, / 로 분리된다면 - 를 사용합니다.<br>

모듈 내의 controller 클래스 명명법 역시 해당 클래스가 담당하는 주소체계를 따르며,<br>
예를들어 module-api-my_service-tk-sample 모듈에서 데이터베이스 테스트 샘플 api 를 모아둔 컨트롤러의 경우는,<br>
/my-service/tk/sample/database-test<br>
주소라고 정했다고 한다면, MyServiceTkSampleDatabaseTestController 라고 이름 지으면 됩니다.<br>

service 클래스 명명의 경우는 controller 클래스에서 정한 이름에서 뒤에 Controller 대신 Service 를 붙이기만 하면 됩니다.

### common 모듈

common 모듈은 뚜렷한 주제로 묶이지 않은 모든 유틸성 코드들이 모이는 중위 모듈입니다.<br>
만약 모듈로 떼어낼 코드가 생긴다면 먼저 이곳에 보낼 것을 고려하고,<br>
이후 별도 모듈로 떼어낼 만하다고 판단한다면 그때 분리해도 좋습니다.

### batch 모듈

spring batch 를 구현한 중위 모듈입니다.<br>
BatchConfig 에서 batch_metadata 데이터베이스 스키마 내에 배치 메타 정보를 저장하도록 설정하였고,<br>

batch_components 안에 Chunk 방식과 Tasklet 방식의 예시를 추가하였습니다.<br>
BatchJobRunner 는 본 프로젝트에서 구현한 batch_components 내의 샘플 배치 작업에 대한 테스트용 트리거 역할을 합니다.

### jpa 모듈
jpa 모듈은 독립성 모듈로, 다른 모든 비독립성 모듈들에 JPA 를 활용한 데이터베이스 활용 함수를 제공합니다.<br>
JpaRepository, NativeQuery 활용, QueryDSL 설정 등이 되어있는데,<br>
저의 경우는 단순한 로직은 JpaRepository 로 처리하고,<br>
복잡한 기능은 NativeQuery 로 처리하는 편입니다.<br>
최근에는 NativeQuery 빈도를 줄이고 QueryDSL 을 적극적으로 사용하려 하고 있습니다.<br>
구현시 특이사항으로는, 하나의 프로젝트 내에 여러 데이터베이스에 접근하여 사용할 수 있도록 멀티 데이터 소스 구조를 구현했고,<br>
이로인하여 DB 트랜젝션 처리 역시 커스텀 어노테이션 및 AOP Aspects 를 구현하여 처리하였습니다.

### kafka 모듈
kafka 모듈은 실행성 모듈로, kafka 미들웨어 서비스를 사용하여 이벤트 브로커를 사용하는 방식을 구현하였습니다.<br>
이러한 모듈 샘플 코드를 참고하여 kafka 클러스터 환경에서의 producers, consumers 이벤트 처리 등을 구현 가능할 것입니다.

### mongodb 모듈
mongodb 모듈은 독립성 모듈로, jpa 모듈과 동일한 성격을 지닌 레포지토리형 모듈입니다.<br>
MongoDB 에서 할 수 있는 기본적인 기능들에 대한 샘플 코드를 제공합니다.<br>
jpa 모듈과 같이 멀티 데이터 소스 구조 및 커스텀 트랜젝션 어노테이션을 구현하였습니다.<br>

### quartz 모듈
quartz 모듈은 Spring Quartz 를 사용한 스케쥴링 기능을 구현한 모듈입니다.<br>
quartz_components 안의 Config 파일로 스케쥴 코드를 작성 가능하며,<br>
트리거 아이디를 적용하여 프로세스 복제시 중복 실행을 방지할 수 있습니다.

### security 모듈
security 모듈은 spring security 설정 모듈로, 위치로는 중위 모듈이라 할 수 있습니다.<br>
app 모듈에서 참조하여 spring security 설정 component 를 JVM 에 올리고,<br>
api 모듈에서 security 설정 정보를 가져와 정당한 처리를 하시면 됩니다.<br>
security 모듈에서 설정된 인증/인가 처리 필터는 api 의 주소체계에 따라 분류하는 식으로 구현하였습니다.
