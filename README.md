# Kotlin Springboot MVC Template Project

## 프로젝트 설명

- 본 프로젝트는 멀티 모듈 구조의 Springboot 개발 템플릿 프로젝트입니다.<br>
  멀티 모듈의 구조는 Layered 아키텍쳐를 커스텀한 것이며,<br>
  모듈 내 폴더 구조 역시 일반성과 가독성을 고려하여 클래스 파일 용도별 분류를 하였습니다.

## 프로젝트 설명 상세

### 모듈 분리 기준

본 프로젝트에서 모듈은 기본적으로 Layered 아키텍쳐 방식으로 구성하였습니다.<br>

각 모듈별 종속성의 흐름은 하나의 방향성을 가지며, 동일 계층간의 참조는 있을 수 있지만,<br>
하위 계층에서의 참조 방향의 역전은 있을 수 없습니다.<br>

예를 들어, <br>

A 모듈이 B, C 모듈을 참조하고 있고, B 모듈이 D, E 모듈을 참조한다면,<br>
A 모듈은 B, C 모듈과 D, E 모듈을 모두 참조가 가능하고,<br>
(되도록 D, E 모듈은 A 모듈에선 사용하지 않는 것을 권장하고, 모듈 연관관계 도식은 필수)<br>
B, C 모듈은 동일 계층인 B, C 와 D, E 모듈을 모두 참조 가능하지만, A 모듈은 참조할 수 없습니다.<br>

또한, 모듈의 분리 기준은,<br>
크게는 기능 단위로 나누어주고, 작게는 api 서비스 단위로 나누어 줍니다.<br>

예를 들어,<br>
app 모듈은 프로젝트 시작을 담당하는 main 함수 및 서버 프로세스의 포트와 같은 설정 담당,<br>
api 모듈은 Springboot MVC 에서의 Controller, Service 담당,<br>
jpa 모듈은 jpa Database 기능 담당.<br>
위와 같이 기능단위로 나누며,<br>

api 모듈과 같이 사용자에게서 온 요청을 받아와서 처리하는 모듈은 서비스 단위를 기준으로 하여,
회원 가입, 로그인과 같은 요청을 처리하는 auth 서비스 단위, 게시판 기능을 담당하는 board 서비스 단위...<br>
이런식으로 하위 서비스 도메인 단위로 모듈을 분리합니다.<br>

즉, 모듈의 종속성을 한방향으로 하여 구조의 복잡도를 낮추고,<br>
모듈을 기능 및 서비스 도메인 단위로 나누어 관심사의 분리를 이루어내어 코드의 복잡성을 낮췄습니다.

실무적인 모듈 분리의 순서를 설명드리자면,<br>

1. 어떠한 기능을 필요에 따라 api 모듈 Service 에서 개발
2. 해당 기능의 코드가 api 기능과는 별개의 영역을 다룬다면, 별도 모듈로 이관 가능한지 확인
3. 별도 모듈로 떼어내는 것이 맞고, 뚜렷한 토픽이 없다면 이 코드를 common 모듈의 함수로 분리
4. 별도 모듈로 분리가 가능하고, 뚜렷한 토픽이 있다면 해당 토픽의 모듈에 이식하고, 만약 기존 모듈이 없다면 새로운 모듈 생성

위와 같습니다.<br>

모듈 분리의 권장 규칙은,<br>

1. 동일 계층 모듈을 참조할 수도 있지만 되도록 하위 모듈만 사용하도록 하기
2. 할 수 있다면 다른 모듈을 참조하지 않는 독립 모듈을 지향하기
3. 각 모듈별 토픽을 엄격히 지키기 (ex : api 모듈은 controller 와 service 만 작성)

위와 같은 구조로 인하여 얻을 수 있는 장점은,<br>
모듈화의 장점인 이식성의 향상과 결합성의 약화를 이루어내고,<br>
구조의 일관된 규칙을 통해 프로젝트 파악의 난이도를 낮추고,<br>
모듈별 단위 테스트를 따로 두어 모듈별 신뢰도를 높이고 분리하여,<br>
오래된 코드에 들어가는 에너지 소모를 막을 수 있으며,<br>
단순한 모듈 구조로 인해 비숙련자도 쉽게 적응이 가능하도록 설계하였습니다.

## 프로젝트 실행 방법

본 프로젝트를 실행시키기 위해서 필요한 조건이 존재합니다.<br>
MySQL or MariaDB, Redis, MongoDB, Kafka<br>
위의 네가지 서비스가 로컬상에 동작해야하며,<br>
RDBMS 는 JPA 모듈에서 설정한 Entity 의 스키마, 테이블 구조를 따라야 합니다.<br>

특히, DB 테이블 구조가 갖춰지지 않는다면 실행 오류가 날 것이며,<br>
JPA 모듈에서는 entities 안의 엔티티 테이블 클래스를 참조하여 DB 구조를 맞춰주시고,<br>
batch 모듈에서는 SpringBatch 에 필요한 Batch 관련 테이블로써,<br>

Gradle 빌드 후 생성되는 외부 라이브러리의<br>
Gradle: org.springframework.batch:spring-batch-core<br>
안의 jar 파일에서 org.springframework.batch.core 안의 sql 파일 내의 내용에 따라<br>
batch_metadata 스키마 안에 테이블을 생성하고,<br>

quartz 모듈은 external_files 안의 knowledges 하위 폴더의 SpringQuartzMySQL.txt 의 SQL 문으로<br>
quartz_metadata 스키마 안에 테이블을 생성하면 됩니다.

모듈별 미들웨어 서비스는 external_files 안의 docker 모음으로 설치가 가능하며,<br>

각 서비스들에 대한 설정은 각 구현 모듈 설정을 변경시켜 실행시킬 수 있습니다.<br>

프로젝트를 정상적으로 실행시켜 Open 된 포트에 웹 브라우저로 접속한다면, 서버의 Welcome 페이지를 확인하실 수 있고,<br>

서버에서 제공해주는 Swagger 문서를 통하여 본 프로젝트에서 구현된 여러 기능들을 테스트 하실 수 있습니다.<br>
(배포 설정인 prod80 프로필로 접속시 보안을 위하여 Swagger 페이지 접속 버튼이 사라지며, Swagger 주소 접근 역시 불가능해 집니다.)

## MSA 구축 철학
기본적으로 본 프로젝트는 서비스 하나를 가정합니다.<br>
이곳에 모든 기능을 다 넣으면 모놀리틱 아키텍쳐가 되는 것이고,<br>
일부 기능을 구현한다면 마이크로 서비스 아키텍쳐의 일부가 되는 것이죠.<br>

저는 서비스 구현을 프로젝트 당 하나의 기능을 담당하도록 만드는 것을 선호합니다.<br>

간혹 프로젝트 내에 멀티 모듈을 구현하여 모듈별 실행 Main 함수를 따로두고, 포트 설정을 바꾸는 형식으로 구현하기도 하는데,<br>
해당 방식이 나쁘다기보다는 MSA 는 기술이 아닌 설계의 영역에 가깝다고 생각하므로, 기술과 독립이 되어야 하며,<br>
추후 관리시 서비스가 프로젝트 단위로 분리되어 있는 것이 보다 서비스간 독립성을 보장한다고 생각하기 때문입니다.<br>

예를들어 같은 MSA 를 구성하는 서로 다른 언어로 구현된 마이크로 서비스들 간에는 프로젝트 단위로 분리를 하므로,<br>
어떤 것은 동일 프로젝트를 공유하고, 어떤 것은 다른 프로젝트로 분리되는 식으로 예외를 주기 보다는<br>
모든 서비스가 프로젝트 단위로 분리되는 것이 이해가 쉽고, 특정 기술에 종속성을 가지지 않는 설계라고 생각합니다.<br>

즉, 제가 MSA 를 구성한다면,<br>
본 프로젝트 구조를 그대로 가져가며, 설계 단계에서 DDD 에 따라 서비스 도메인과 하부 도메인을 설계한 후,<br>
마이크로 서비스 설계에 맞게 프로젝트를 분리하여 각 서비스를 구현하는 방식을 사용할 것이며,<br>
더 나아가서 Spring Cloud(API 기반이므로 NodeJS, Python 서버 등 호환 가능) 스택과 같은 마이크로 서비스 툴을 사용하여,<br>
MSA 운영시의 안정성을 재고할 것입니다.

## 사용 포트 번호

admin 9090 v
admin-client1 9191 v
admin-client2 9192 v

cloud gateway 8080 v
cloud eureka1 10001 v
cloud eureka2 10002 v
cloud eureka3 10003 v
cloud-sample-client 10101 v
cloud-sample-client-copy 10102 v

template 10000 v

auth 11000 v

sample-etc 12000 v
sample-scheduler 12003 v
sample-socket 12004 v
sample-kafka 12005 v
sample-api 12006 v
sample-retrofit2 12007 v
sample-redis 12008 v
sample-mongodb 12009 v
sample-jpa 12010 v
sample-batch 12011 v
sample-quartz 12012 v
sample-just-security 12013 v

portfolio-board 13000
(열람 회수 증가는 redis 를 사용하여 회수를 늘리고, quartz로 데이터베이스에 반영하도록 합니다.)